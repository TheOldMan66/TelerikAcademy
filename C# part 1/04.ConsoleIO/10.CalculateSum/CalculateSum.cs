/* Write a program to calculate the sum (with accuracy of 0.001): 1 + 1/2 - 1/3 + 1/4 - 1/5 + ... */

using System;

namespace _10.CalculateSum
{
    class CalculateSum
    {
        static void Main()
        {
            double sum = 1.0d;
            double increment = 0.0d;
            int i = 2;
            do
            {
                increment = (1.0d / i) - (1.0d / (i + 1));
                sum = sum + increment;
                i = i + 2;
            } while (increment > 0.00000001d);
            Console.WriteLine("Sum is equal to {0:F3}",sum);
        }
    }
}
/* Едно пояснение към алгоритъма: Реда 1 + 1/2 - 1/3 + 1/4 - 1/5 е сходящ, но никой не може да 
 * каже колко итерации трябва да се извъртят за да спре да се променя 4-я знак след десетичната
 * точка (или поне не без висша математика). Твърдението че "ако прибавям число по-малко от 0.0001
 * към сумата то съм стигнал границата" е .... леко погрешно. Пример: ако към 1.307 (което е горе-долу 
 * решението) прибавяш първо 0.0008, след това 0.0006, след това 0.0004, после 0.0002... ще се 
 * окаже че си прибавил 0.0020, т.е. 2 единици в "значещия" разряд, макар че прибаваш числа по-малки
 * от 0.001. Спрял съм се на точност два пъти по-голяма от исканата в условието, предполагам че с нея
 * вече ще съм излезнал от "сивата зона", която би могла да промени значеща цифра.
 * И ... извинявам се за кирилицата, но ако трябваше да го пиша на английски щях да го мисля 1/2 ден :) */